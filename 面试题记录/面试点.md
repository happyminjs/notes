### 不同页面通信的方式
##### storage 事件
##### cookie + 轮询
##### postMessage
可以安全地实现跨源通信  
要求：
* 相同协议
* 相同端口号
* 相同主域，子域不同需要设置Document.domain相同
语法： 
```js
targetWindow.postMessage(message, targetOrigin, [transfer]);
```
###### targetWindow
获得引用的方法：
* 执行 window.open 返回的窗口对象
* Window.opener: 创建该窗口的 Window 对象的引用
* 比如iframe的contentWindow属性： HTMLIFrameElement.contentWindow
* Window.parent: 当前窗口的父窗口
* 命名过或数值索引的 window.frames
###### message
将要发送到其他 window的数据
###### targetOrigin
指定哪些窗口能接收到消息事件，可以是 '*'， 或者一个 URL
###### transfer
可选参数。和message 同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方
```js
// 发送端
var receiver = document.getElementById('receiver').contentWindow;
var btn = document.getElementById('send');
btn.addEventListener('click', function (e) {
    e.preventDefault();
    var val = document.getElementById('text').value;
    receiver.postMessage(`Hello ${val}！balabala`);
});
// 接收端 targetWindow
window.addEventListener("message", receiveMessage, false);
function receiveMessage(event){
  if (event.origin !== "http://www.42du.cn")
    return;
}
```
###### event对象的属性
* origin: postMessage的发送来源，包括协议，域名和端口
* data: 接收到的消息
* source: 发送消息的窗口对象的引用; 我们可以用这个引用来建立两个不同来源的窗口之间的双向通信。

-----------


### 不同进程之间通信
### vue实现思想（数据双向绑定、虚拟dom，diff算法，vue.use, vue.component）
https://www.cnblogs.com/wind-lanyan/p/9061684.html
### vue router
单页面进入判断登录
### css的局部作用域 已 vue 的 scoped 属性为例
### 模块化
### 原型链
https://juejin.im/post/58f94c9bb123db411953691b
### 继承
继承主要依靠原型链来实现的
https://juejin.im/post/58f94c9bb123db411953691b

### 闭包

### Web缓存
##### 缓存优先级
* 1、Service Worker
* 2、Memory Cache
* 3、Disk Cache
* 4、Push Cache（在国内还不够普及）
* 5、网络请求
###### Service Worker
我们可以自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
###### Memory Cache
就是内存中的缓存，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
###### Disk Cache
存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。就算关闭了tab页面，还是会存在硬盘当中。
###### Push Cache （在国内还不够普及）
缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。
###### 网络请求
所有缓存都没有命中的话，那么只能发起请求来获取资源了。 
###### 谷歌浏览器大概自动按照下面的策略缓存
* js： 特别小的不缓存，直接请求。稍微大一些的放Memory Cache，再大一些的Disk Cache，
* css: Disk Cache
* 图片：Memory Cache
##### 缓存策略
浏览器缓存策略分为两种：**强缓存**和**协商缓存**，并且缓存策略都是通过设置 HTTP Header 来实现的。
###### 强缓存
设置两种 HTTP Header 实现：**Expires** 和 **Cache-Control**，强缓存表示在缓存期间不需要请求，state code 为 200。一般需要设置两个属性，用来兼容不同http的版本。
* Expires  **HTTP 1.0**
```js
Expires: Wed, 22 Oct 2018 08:41:00 GMT
// 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。
// Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
// 响应头中设置
```
* Cache-control **HTTP 1.1**
```js
Cache-control: max-age=30
// 该属性值表示资源会在 30 秒后过期，需要再次请求。
// 优先级高于 Expires 。
// 可以在请求头或者响应头中设置
```
###### 协商缓存
如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：**Last-Modified** 和 **ETag** 。
当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 **304** 状态码，并且更新浏览器缓存有效期
* Last-Modified 和 If-Modified-Since  **HTTP 1.0**
```
1、Last-Modified 表示本地文件最后修改日期，在服务端response header中设置此字段；
2、在下一次的request header 中会自动带 If-Modified-Since 字段发送给服务器，
  值为Last-Modified 的值，询问服务器在该日期后资源是否有更新，
3、服务端有更新的话就会将新的资源发送回来，否则返回 304 状态码。
```
```
Last-Modified 存在一些弊端：

1、如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，
  服务端不能命中缓存导致发送相同的资源
2、因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，
  那么服务端会认为资源还是命中了，不会返回正确的资源
```
* ETag 和 If-None-Match  **HTTP 1.1**
```
1、ETag 类似于文件指纹，服务端 response header 中设置 ETag 字段
2、在下一次的request header 中会自动带 If-None-Match 字段发送给服务器，
  值为ETag的值，
3、服务器检测该资源 ETag 是否变动，有变动的话就将新的资源发送回来，否则返回304。
  并且 ETag 优先级比 Last-Modified 高。
```
###### 未手动设置缓存策略
通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。
##### 实际应用
* 频繁变动的资源
```
使用 Cache-Control: no-cache 使浏览器每次都请求服务器，
然后配合 ETag 或者 Last-Modified 来验证资源是否有效。
这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。
```
* 代码文件
```
除了 HTML 外的代码文件:
我们现在都使用工具来打包代码，对文件名进行hash处理。
只有代码修改后重新编译会生成新的文件名，可以给代码文件设置缓存长一点，Cache-Control: max-age=31536000， 
这样只有html引入的文件名发生了变化，才会重新请求资源。
```
--------------------
### 网络安全： XSS 、 CSRF攻击、 点击劫持、 中间人攻击
##### XSS
攻击者将可执行的代码注入到网页中。  
一般分为两种：  
* 持久型： 攻击的代码被服务端写入进数据库中，例如评价内容等
* 非持久型： 一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。例如页面需要从url中获取数据直接展示到了页面上
###### 防御方法
* 转义字符： 对于用户的输入应该是永远不信任的。转义输入输出的内容，对于引号、尖括号、斜杠进行转义
* 转义字符 + 白名单： 解决富文本直接转义导致无法正常使用的问题
* CSP： 本质就是建立白名单。开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。
```
// 开启方式
1、设置 HTTP Header 中的 Content-Security-Policy
2、设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy">
```
##### CSRF
跨站请求伪造: 攻击者构造出一个请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑
###### 防御方法
* Get 请求不对数据进行修改
* 不让第三方网站访问到用户 Cookie
* 阻止第三方网站请求接口， 验证 Referer
* 请求时附带验证信息，比如验证码
* 请求时附带 Token： 服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。
##### 点击劫持
是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
<image src="/imgs/click_safe" width=400></image>
###### 防御方法
* 设置 HTTP 响应头 X-FRAME-OPTIONS
```js
配置取值
DENY: 表示页面不允许通过 iframe 的方式展示
SAMEORIGIN: 表示页面可以在相同域名下通过 iframe 的方式展示
ALLOW-FROM: 表示页面可以在指定来源的 iframe 中展示

// 不支持的浏览器中
<head>
  <style id="click-jack">
    html {
      display: none !important;
    }
  </style>
</head>
<body>
  <script>
  // 一个页面可能会有很多层，top 是指最顶层的框架
  // self 是指当前窗口
    if (self == top) {
      var style = document.getElementById('click-jack')
      document.body.removeChild(style)
    } else {
      top.location = self.location
    }
  </script>
</body>
```
##### 中间人攻击
攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。  
一般使用公共WiFi等时会发生
###### 防御方法
增加一个安全通道来传输信息。例如 HTTPS
### HTTP
##### 基本优化
* 带宽：拨号上网的阶段带宽影响较大，但现在网络基础建设使带宽提升很多，不是主要问题了
* 延迟：
  * 浏览器阻塞： 浏览器对于同一个域名，同时只能有 4 个连接。超过最大连接数限制，后续请求就会被阻塞
  * DNS 查询： 浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的
  * 建立连接： HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接。每次请求都要经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
#### HTTP1.0 和 HTTP1.1 的一些区别
###### 缓存处理
```
HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，
HTTP1.1则引入了更多的缓存控制策略。
例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
```
###### 带宽优化及网络连接的使用
```
HTTP1.0中，存在一些浪费带宽的现象，
  例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
HTTP1.1则在请求头引入了range头域，
  它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
```
###### 错误通知的管理
```
在HTTP1.1中新增了24个错误状态响应码。
如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
 410（Gone）表示服务器上的某个资源被永久性的删除。
```
###### Host头处理
```
HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，
  因此，请求消息中的URL并没有传递主机名（hostname）。
HTTP1.1中在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。
HTTP1.1的请求消息和响应消息都应支持Host头域，
  且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
```
###### 长连接
```
HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，
在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，
在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
```
#### HTTPS与HTTP的一些区别
* HTTPS协议需要到CA申请证书
* HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
* HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
* HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

------------
### 三次握手、四次挥手

### 

### DOM 加载完毕 和 更新完毕事件
```js

```
--------------------

### DOM 的各种宽度
名词解释：
* screen：屏幕。这一类取到的是关于屏幕的宽度和距离，与浏览器无关。
* client：使用区、客户区。指的是客户区，当然是指浏览器区域。
* offset：偏移。指的是目标甲相对目标乙的距离。
* scroll：卷轴、卷动。指的是包含滚动条的的属性。
* inner：内部。指的是内部部分，不含滚动条。
* avail：可用的。可用区域，不含滚动条，易与inner混淆。

常用方法：
* 屏幕宽度：window.screen.width
* 浏览器内宽度：window.innerWidth || document.documentElement.clientWidth
* 元素内容宽度：element.clientWidth
* 元素占位宽度：element.offsetWidth
##### window.innerWidth/innerHeight
浏览器可见区域的内宽度、高度（不含浏览器的边框，但包含滚动条）
##### window.outerWidth/outerHeight
浏览器外宽度（包含浏览器的边框，因各个浏览器的边框边一样，得到的值也是不一样的）
##### window.screenLeft/screenTop
浏览器的位移  
* ie浏览器的内边缘距离屏幕边缘的距离。  
* chrome浏览器的外边缘距离屏幕边缘的距离。  
##### window.screenX/screenY
也是 浏览器的位移 ，但是ie的包括边框等部分 
* ie9/10浏览器的外边缘距离屏幕边缘的距离
* chrome浏览器的外边缘距离屏幕边缘的距离
##### window.pageXOffset/pageYOffset
表示浏览器X轴（水平）、Y轴（垂直）滚动条的偏移距离
##### window.scrollX/scrollY
也是 浏览器X轴（水平）、Y轴（垂直）滚动条的偏移距离
##### screen.width/height
屏幕的宽度、高度
##### screen.availWidth/availHeight
屏幕的可用宽度、高度（通常与屏幕的宽度、高度一致）
##### elment.clientWidth/clientHeight
box-sizing: content-box;标准：
document.getElementsByClassName('B')[0].clientWidth
元素的content + padding * 2（不包括元素的滚动条宽度）即：
* 有滚动条时：clientWidth=元素左内边距宽度+元素宽度+元素右内边距宽度-元素垂直滚动条宽度  
* 无滚动条时：clientWidth=元素左内边距宽度+元素宽度+元素右内边距宽度
##### element.clientLeft/clientTop
clientLeft为左边框宽度，clientTop为上边框宽度。
##### element.offsetWidth/offsetHeight
元素的 content + padding * 2 + border * 2
##### element.offsetLeft/offsetTop
该元素相对于最近的定位祖先元素的距离
* chrome：offsetLeft = 定位祖先左边框宽度 + 定位祖先元素左内边距宽度 + 左位移 + 左外边距宽度
* 其他：offsetLeft=定位祖先元素左内边距宽度+左位移+左外边距宽度
##### element.scrollWidth/scrollHeight
* 有滚动条时： 左内边距宽度 + 内容宽度
* 无滚动条时：左内边距宽度+宽度+右内边距宽度
##### element.scrollLeft/scrollTop
获得水平、垂直滚动条的距离。

-------------------

### Dom操作、事件（创建、插入位置、子元素、兄弟节点、父亲节点）
###### 创建DOM
```js
var divDom = document.createElement('div');
```
###### 添加属性
```js
var divId = document.createAttribute("id");
divId.value = 'name';
divDom.setAttributeNode(divId);
```
###### 添加文本
```js
var pText = document.createTextNode("我是文本");
divDom.appendChild(pText);
```
###### 插入DOM
```js
// 向节点 fatherDom 添加最后一个子节点
fatherDom.appendChild(divDom)
// 向节点 fatherDom 所有子节点之前插入一个新的子节点
fatherDom.insertBefore(divDom)
// 拼接元素的字符串，可以利用父元素的innerHTML设置父元素的内容
fatherDom.innerHTML="<p>啊啊啊</p>"
```
<font color=red>注意: </font> <font size="2">如果是获取的页面中存在的元素，会删除原有节点。所以 appendChild 和 insertBefore 这两个方法都可以用来从一个元素向另一个元素中移动</font> 
###### 替换DOM
替换下例中的item的内部元素
```js
divDom.replaceChild(newnode,oldnode)
// 例：
var textnode = document.createTextNode("Water");
var item = document.getElementById("item");
item.replaceChild(textnode, item.childNodes[0]);
```
###### 删除DOM
如需删除某个 HTML 元素，您需要知晓该元素的父节点。
```js
fatherDom.removeChild(divDom);
```
###### 遍历
```js
node.children   // 只返回子元素节点，不支持ie低版本
node.childNodes // 所有的子节点，包括文本节点、注释节点
node.firstChild  // 第一个子元素
node.lastChild // 最后一个子元素
node.previousSibling // 相同的树层级中的上一个相邻元素，若没有返回 null
node.nextSibling // 相同的树层级中的下一个相邻元素，若没有返回 null
node.parentNode // node 的直接父元素
```
通过封装 childNodes + node.nodeType 可以实现 children 的效果：
```js
var nodeList = fatherDom.childNodes;
var ary = [];
for(var i = 0; i < nodeList.length; i++){
  var curNode = nodeList[i];
  if(curNode.nodeType ===1){
    ary[ary.length] = curNode;
  }
}
// nodeType 常用的取值：
// 1: node元素
// 2: 属性
// 3: 元素中或属性中的文本内容
// 8: 注释 
```
获取某个特定的元素，如：某个类型为 tagName 的子元素
```js
for(var k = 0; k < ary.length; k++){
  var curTag = ary[k]; // ary是children返回数组或者上边例子中返回的ary
  if (curTag.nodeName.toLowerCase() !== tagName.toLowerCase()){
    break;
  }
}
console.log(ary[k]);
```
###### 获取元素内容
```js
Dom.textContent // 只有本身及所有子元素的文本内容
Dom.innerHTML // 包括标签和属性
```
总结汇总：
<image width=600 src="/imgs/dom.png"></image>

-----------------------------












