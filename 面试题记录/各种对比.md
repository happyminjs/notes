### 箭头函数和普通函数的区别
* 没有this，永远指向其上一级上下文的this，普通函数指向调用它的对象
* call、apply、bind 并不会影响其 this 的指向
* 箭头函数是匿名函数，不能作为构造函数，不能new 
    ```
    因为没有this啊，new的时候需要this指向新创建的对象呢
    ```
* 不能绑定arguments，而是用 解构... 解决
* 箭头函数没有原型属性 prototype
* 箭头函数不能当作 Generator 函数，不能使用 yield 关键字

### Map 和 Object 的对比
* 用法对比
```
Object 的键只能是字符串、数字、Symbol，Map 的键可以任意类型；
Object 是无序的， Map会保持插入的顺序；
读取长度：Object.keys(obj).length, map.size()
Object 默认不可迭代，只能通过 for in 或者 Object.keys(obj) 等方法， Map是可迭代对象；
新增键时，Object可能会覆盖原型上的属性， Map 不会覆盖；
Object支持JSON方法，Map 默认不支持
```
* 语法对比
```
创建： new Map([[key, value]]);  map.set(key, value)
读取: map.get(key)
删除：map.delete(key)
```
* 性能对比
```
创建空的，Object 更 优
新增元素时，Map 明显速度更优，内存占用也少很多
读取元素时，Object略优
删除元素时，差别不大
```
* 使用选择
```
使用 Map:
  储存的键非字符串、数字、Symbol  
  储存数据量大，且需要大量增删操作
  需要保持插入顺序时
  需要迭代遍历时

使用 Object: 
  只是简单数据结构，因为数据少时，内存占用更少，且创建速度更快
  需要JSON进行文件传输时，因为 Map 默认不支持
  需要多个键值对操作运算时，因为Map语法稍复杂
  需要覆盖原型上的键时
```
虽然大家都说Map性能更优，但是他只是个别情况下更适合而已，并不能替代Object，不然也不会还是Object是基础的引用类型。
### const跟 Object.freeze
const 是 **内存地址不可变**；  freeze 是**对象不可变**，而变量是可以重新赋值的。  
注意两个api都是浅限制。
```js
const c = { aa: 1, bb: {bbb: 2}};
c = {cc: 3}; // 会报错
c.aa = 'aa'; // 修改成功

let o = { aa: 1, bb: {bbb: 2}};
Object.freeze(o);
o.aa = 'aa'; // ES5 中会报错，ES6中不报错，但是也不会修改变量
o.bb.bbb = 'bb'; // 修改成功
o = {cc: 3}; // 修改成功
```
freeze是冻结了一个对象，不能添加、删除、修改这个对象的属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值；该对象的原型也不能被修改。
### async await 与 promise 
```
async await:
  真正的串行的同步写法，代码阅读相对容易
  无法处理promise返回的reject对象，要借助try...catch
  导致性能问题，因为 await 会阻塞代码，可能后边代码并不依赖前者
  try catch 内部变量不会传递给下一个

promise：
  无法中途取消，链式调用多个then中间不能随便跳出来
  错误无法在外部被捕捉到，只能在内部进行预判处理，若没有回调函数，Promise内部抛出的错误，不会反应到外部
  内部检测困难，pending状态时，无法得知目前进展到哪一个阶段
```
#### fetch,Ajax,axios区别
* Ajax: 是（Asynchronous JavaScript and XML）的缩写。现在，允许浏览器与服务器通信而无须刷新当前页面的技术都被叫做Ajax。核心使用XMLHttpRequest对象。
* axios: 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范。
* Fetch 被称为下一代Ajax技术,采用Promise方式来处理数据。比XMLHttpRequest更加简单易用。

### js中的堆、栈和队列
堆(heap)和栈(stack)的区别:
* 堆：队列优先,先进先出；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
* 栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。
* 栈是先进后出，队列是先进先出。

