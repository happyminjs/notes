#### 单例模式
单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回。
```js
function Singleton() {
    this.a = 'aaa';
    this.b = 'bbb';
}
var singleton = singleton || new Singleton();
```
#### 工厂模式
创建多个相似对象（未解决对象识别问题）
```js
function factory(name,age){
    var f = new Object();
    f.name = name;
    f.age = age;
    f.sayName = function(){
        alert(this.name);
    };
    return f;
}
var f1 = factory("Nicholas",29);
var f2 = factory('Gray',20);
```
#### 构造函数模式
用于创建特定类型的对象，声明了对象的同时，也可以声明自定义类型对象的属性或方法（调用一次，创建一次，不同实例上的同名函数是不不等的）
```js
function Person(name,age){
    this.name = name;
    this.age = age;
    this.sayName() = function(){
        alert(this.name);
    };
}
var p1 = new Person("Nicholas",29);
```
#### 观察者模式
一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己
```js
function Event(observer) {
    this._observer = observer;
    this._listeners = [];
}
Event.prototype = {
    constaructor: 'Event',
    attach: function(listeners) {
        this._listeners.push(listeners);
    },
    notify: function(objs){
        for(var i = 0,ilen = this._listeners.length; i < ilen; i++) {
            this._listeners[i](this._observer,objs);
        }
    }
};
```
#### 钩子hook
```js
var hook = {// hook 里边是不同部分
    'a': function() {
       return 'a';
    },
    'b': function() {
        return 'b';
    },
    'c': function() {
        return '';
    }
};
var str = 'b';
console.log('hello,' + hook[str]());
```

-----------------------
### 模块化
将项目按照功能划分，理论上一个功能一个模块，互不影响，按需加载
**模块化分类：**
* CommonJS
```
1、一个单独的js就是一个模块
2、每个模块都有一个单独的作用域，
3、导出方式： exports.aa = aa; 和 module.exports = {}
4、模块导入： require()
```
* AMD
```
1、预加载
2、应用需要：RequireJS
```
* CMD
```
1、懒加载
2、应用需要： SeaJS
```
-----
### module.exports 、 exports 、 export 、 export default 、 import()
下面主要介绍的是CommonJS和ES6中的方法  
* 前者是值的拷贝，后者是值的引用
```
值拷贝的意思是一旦输出一个值，模块内的变化不会影响到这个值，
值的引用是说只会生成一个只读索引，脚本真正运行时，在根据这个地址到被加载的那个模块中去取值
```
* 前者只能一个对象；后者可以对象、变量、function都可以
* 前者是运行时加载，后者是编译时输出接口（只能在模块的顶层，不能在代码块之中，所以条件加载就不可能实现）
```
编译时：代码还没有提交到内存中运行起来，还在硬盘中保存，属于静态定义（编译器对代码进行语法检查等操作） 
运行时：代码编译没有问题后，提交到内存中跑起来了，属于动态定义
```
#### CommonJS 规范
node.js应用的此规范。
* 通过<font color=red>require</font>方法来<font color=red>同步</font>加载依赖的其他模块  
* 通过<font color=red>module.exports</font>导出需要暴露的接口  

每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。
##### module.exports
```js
// a.js
let appid = '123456'
let bar = function (id) {
  return id
}
// 通过module.exports将appid与bar暴露出去
module.exports = {
  appid, bar
}

// 通过require引入utils
let utils = require('./a');
console.log(utils.appid) // 123456
console.log(utils.bar(2)) // 2
```
##### exports
是module.exports的简写。因为Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行 let exports = module.exports 的命令。
<font color=red>注意：不能直接将exports变量赋值为一个值。因为 node 内部 return 的是 module.exports，直接给 exports 赋值的话，exports 就不是指向 module.exports 了。</font>
```js
let appid = '123456'
// 错误写法
exports = {
	appid
}
// 正确写法
exports.appid = appid
```
#### ES6 规范
使用 export 和 import 来导出、导入模块。其中 export 和 export default 之间也有些区别：  

##### export
<font color="red">export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</font>看下边例子：
```js
export 1; // 报错

var m = 1;
export m; // 报错

function f() {}
export f; // 报错
```
因为没有提供对外的接口。
第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。
1只是一个值，不是接口。 正确的应该下边这样用：  
```js
// a.js
export const m = '1'
export function getAppid() {
  return '1'
}
function f() {}
export {f};
// ------------------------------------------------------
// 导出的几种方式：
import { appid , getAppid } from './utils' // 导入多个导出
import * as utils from 'utils' // 作为命名空间导入整个模块
console.log(appid) // 123234
console.log(getAppid ()) // 123456
```
##### export default
为模块指定默认输出。本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。  
所以：
* import命令可以为导出的内容指定任意名字。  
```js
// a.js
export default function() {}

// b.js
import utils from './a'
```
* 不能跟变量声明语句  
```js
export default const appid = '123456'  // 报错
```
* 可以直接将一个值写在export default之后。  
```js
export default 42;
```
同时输入默认方法和其他接口  
```js
import fn3, { a, fn1} from './a';
// let module = await import('./a'); // 支持await关键字
```
##### import()
为解决es6中的 import 不能动态按需加载提出的提案。  
import()返回一个 Promise 对象。  
```js
import('./dialogBox.js').then(dialogBox => {
  dialogBox.open();
}).catch(error => {
  /* Error handling */
})
```
--------------