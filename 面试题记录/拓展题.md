#### 碰到过哪些问题
* 微信给小程序分配内存有限，在复杂操作的时候导致小程序崩溃，sku切换
```
原因：当时sku给的是数组格式的（历史问题），每次切换sku都要遍历很大的数组，导致小程序崩溃。
方案：进入页面的时候遍历一次数组，将数组转为对象格式，这样只需要遍历一次就好，之后切换sku只需要直接根据sku的key直接取值即可。
```
* 58APP使用的WKwebview，老版的Safari做的限制，滚动中不执行js，导致动态设置样式如吸顶的时候闪现
```
方案： 在ios上使用 css 定位： position:sticky; 
```
* 移动端 1px 边框的问题
```
使用0.5px，部分手机上回丢失底边框或者右边框
使用 after 伪元素 + transform：scale(0.5)
其实这个0.5不是严格的1px，只是细了而已
```
* ios 返回 不刷新页面，安卓刷新页面，数据变更、状态保存
* 移动端底部有固定按钮，页面有输入框时
```
监测focus事件，或者监测window.resize事件，控制底部按钮的隐藏和显示
底部固定的输入框： 修改fixed布局为absolute
```
* 只有联通网络时，页面访问失败
  联通的缓存数据出错，cdn缓存出错
* 之前微信将 video 标签层级设置最高，不能在上边添加遮盖元素。
* ios 微信内不能自动播放音视频，可以在微信提供的 WeixinJSBridgeReady事件中播放。
```
document.addEventListener('WeixinJSBridgeReady', function() {
  ...
  audio.play();
  ...
}, false)
```
* 微信支付报错，是因为微信在另一个手机上登录，上一个手机上的账号没有踢下线
* 微信限制： 复制到剪贴板上的图片，之前公司的图片就不能复制到输入框
  换了公司cdn就可以了，具体原因不明
* 应用tips：列表里边的多个标签展示个数问题
* webpack 的版本问题，坑啊。dev启动不起来，报个什么 .call 的错误

---------

#### 优化方法
##### 渲染过程
* 减少重绘和回流
```
1、使用 transform 替代 top
2、使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
3、不要把节点的属性值放在一个循环里当成循环里的变量
4、不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
5、动画实现的速度的选择，动画速度越快，回流次数越多
```
* 懒加载，优化首屏展示
* css： 扁平层级，优化选择器
##### 网络相关
* 合适的缓存策略: 强缓存 协商缓存
```js
具体内容看下一节中的 web 缓存
```
* 应用CDN，并行加载更多资源。因为浏览器对于单个域名有并发请求上限
* DNS 预解析： 通过预解析的方式来预先获得域名所对应的 IP
```html
<!-- href 配置要预解析的域名 -->
<link rel="dns-prefetch" href="//www.ym.cn" />
```
* 预加载： 强制浏览器请求资源，并且不会阻塞 onload 事件
```js
<link rel="preload" href="http://example.com">
// 可以一定程度上降低首屏的加载时间，
// 因为可以将一些不影响首屏但重要的文件延后加载，
// 唯一缺点就是兼容性不好
```
* 预渲染: 将下载的文件预先在后台渲染
```js
<link rel="prerender" href="http://example.com" />
// 要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染
```
##### 文件优化
* 雪碧图、小图使用base64、正确图片格式
* 文件大小合理控制
* css放head 中，script 标签放在 body 标签底部
##### 其他
* 模块化，提取公用模块
* 节流
* 防抖
* 使用 Webpack 优化项目
```
1、对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
2、使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
3、优化图片，对于小图可以使用 base64 的方式写入文件中
4、按照路由拆分代码，实现按需加载
5、给打包出来的文件名添加哈希，实现浏览器缓存文件
```
-----------
#### Web缓存
##### 缓存优先级
* 1、Service Worker
* 2、Memory Cache
* 3、Disk Cache
* 4、Push Cache（在国内还不够普及）
* 5、网络请求
###### Service Worker
我们可以自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
###### Memory Cache
就是内存中的缓存，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
###### Disk Cache
存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。就算关闭了tab页面，还是会存在硬盘当中。
###### Push Cache （在国内还不够普及）
缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。
###### 网络请求
所有缓存都没有命中的话，那么只能发起请求来获取资源了。 
###### 谷歌浏览器大概自动按照下面的策略缓存
* js： 特别小的不缓存，直接请求。稍微大一些的放Memory Cache，再大一些的Disk Cache，
* css: Disk Cache
* 图片：Memory Cache
##### 缓存策略
浏览器缓存策略分为两种：**强缓存**和**协商缓存**，并且缓存策略都是通过设置 HTTP Header 来实现的。
###### 强缓存
设置两种 HTTP Header 实现：**Expires** 和 **Cache-Control**，强缓存表示在缓存期间不需要请求，state code 为 200。一般需要设置两个属性，用来兼容不同http的版本。
* Expires  **HTTP 1.0**
```js
Expires: Wed, 22 Oct 2018 08:41:00 GMT
// 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。
// Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
// 响应头中设置
```
* Cache-control **HTTP 1.1**
```js
Cache-control: max-age=30
// 该属性值表示资源会在 30 秒后过期，需要再次请求。
// 优先级高于 Expires 。
// 可以在请求头或者响应头中设置
```
###### 协商缓存
如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：**Last-Modified** 和 **ETag** 。
当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 **304** 状态码，并且更新浏览器缓存有效期
* Last-Modified 和 If-Modified-Since  **HTTP 1.0**
```
1、Last-Modified 表示本地文件最后修改日期，在服务端response header中设置此字段；
2、在下一次的request header 中会自动带 If-Modified-Since 字段发送给服务器，
  值为Last-Modified 的值，询问服务器在该日期后资源是否有更新，
3、服务端有更新的话就会将新的资源发送回来，否则返回 304 状态码。
```
```
Last-Modified 存在一些弊端：

1、如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，
  服务端不能命中缓存导致发送相同的资源
2、因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，
  那么服务端会认为资源还是命中了，不会返回正确的资源
```
* ETag 和 If-None-Match  **HTTP 1.1**
```
1、ETag 类似于文件指纹，服务端 response header 中设置 ETag 字段
2、在下一次的request header 中会自动带 If-None-Match 字段发送给服务器，
  值为ETag的值，
3、服务器检测该资源 ETag 是否变动，有变动的话就将新的资源发送回来，否则返回304。
  并且 ETag 优先级比 Last-Modified 高。
```
###### 未手动设置缓存策略
通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。
##### 实际应用
* 频繁变动的资源
```
使用 Cache-Control: no-cache 使浏览器每次都请求服务器，
然后配合 ETag 或者 Last-Modified 来验证资源是否有效。
这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。
```
* 代码文件
```
除了 HTML 外的代码文件:
我们现在都使用工具来打包代码，对文件名进行hash处理。
只有代码修改后重新编译会生成新的文件名，可以给代码文件设置缓存长一点，Cache-Control: max-age=31536000， 
这样只有html引入的文件名发生了变化，才会重新请求资源。
```
--------------------
#### 不同页面通信的方式
##### 使用 localStorage 和 storage 事件
```
1、使用 localStorage.setItem(key,value) 添加内容
2、另一个页面使用 storage 事件监听添加、修改、删除的动作
window.addEventListener('storage', function(event){
    console.log(event.key, event.newValue)
})
```
##### 使用 cookie + setInterval 轮询
```html
<input id="name"><input type="button" id="btnOK" value="发送">
```
```js
// 页面 1 
$('#btnOK').click(function(){
    var name = $("#name").val();
    document.cookie = "name" + name
})
// 页面 2
function getCookie(key){
    let cookieArr = document.cookie.split(';')
    let cookieObj = {}
    cookieArr.forEach((cookie, index) => {
        cookie = cookie.replace(/(^\s*)|(\s*$)/g,''); // 去掉头尾的空格
        let index = cookie.indexOf('=')
        let cookieKey = cookie.substring(0, index)
        cookieObj[cookieKey] = cookie.substring(index + 1)
    })
    return cookieObje[key]
}
setInterval(function(){  // 每隔一秒获取cookie的内容
    console.log(getKey('name'))
}, 1000)
```
##### postMessage
可以安全地实现跨源通信  
要求：
* 相同协议
* 相同端口号
* 相同主域，子域不同需要设置Document.domain相同
语法： 
```js
targetWindow.postMessage(message, targetOrigin, [transfer]);
```
###### targetWindow
获得引用的方法：
* 执行 window.open 返回的窗口对象
* Window.opener: 创建该窗口的 Window 对象的引用
* 比如iframe的contentWindow属性： HTMLIFrameElement.contentWindow
* Window.parent: 当前窗口的父窗口
* 命名过或数值索引的 window.frames
###### message
将要发送到其他 window的数据
###### targetOrigin
指定哪些窗口能接收到消息事件，可以是 '*'， 或者一个 URL
###### transfer
可选参数。和message 同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方
```js
// 发送端
var receiver = document.getElementById('receiver').contentWindow;
var btn = document.getElementById('send');
btn.addEventListener('click', function (e) {
    e.preventDefault();
    var val = document.getElementById('text').value;
    receiver.postMessage(`Hello ${val}！balabala`);
});
// 接收端 targetWindow
window.addEventListener("message", receiveMessage, false);
function receiveMessage(event){
  if (event.origin !== "http://www.42du.cn")
    return;
}
```
###### event对象的属性
* origin: postMessage的发送来源，包括协议，域名和端口
* data: 接收到的消息
* source: 发送消息的窗口对象的引用; 我们可以用这个引用来建立两个不同来源的窗口之间的双向通信。

-----------
### localStoroge 存储满了后继续存储会怎样？如果满了要怎么处理？
只有5M容量，如果满了会报错(Uncaught QuotaExceededError: Failed to set the 'YourStorageKey' property on 'Storage': Setting the value of 'YourStorageKey' exceeded the quota.)
```js
1、划分子域名，按业务线统一规划使用
2、跨页面传数据，考虑单页面应用，优先采用url传数据
3、最后兜底方法，清掉别人的存储，所以前提是自己存储时要有统一前缀
function setLocalStorage (key, data) {
    try {
        localStorage.setItem(key, data);
    } catch (e) {
        if (e.code === 22) {  // 22 代表是存储满了，写入失败
            localStorage.clear(); // 这里最好是自己的业务有统一key前缀，不删自己的
            localStorage.setItem(key, data);
        }
    }
}
```
---------------
### 不同进程之间通信


-----
### 三次握手、四次挥手
https://blog.csdn.net/qq_38950316/article/details/81087809

----

### 浏览器输入一个URL都发生了什么
* 一、DNS解析: 主机名和域名转换成IP地址
```
解析过程：
1、检查浏览器缓存
2、本机缓存
3、本地域名解析服务器发起域名解析请求
4、向根域名解析服务器发起域名解析请求
5、根域名解析服务器返回gTLD(通用顶级域)域名解析服务器地址
6、向gTLD服务器发起解析请求
7、gTLD服务器接收请求并返回名称服务器
8、名称服务器返回ip地址给本地服务
9、本地域名服务器缓存解析地址
10、返回解析结果给用户

负载均衡：
在域名解析服务器中为一个域名配置多个ip地址，
这样在应答域名查询时就可以将DNS记录中的IP地址按一定顺序返回不同的解析结果，
将用户引导到不同的机器上去，使得不同用户访问不同的服务器，从而达到负载均衡的效果
```
* 二、根据ip建立TCP连接（三次握手）
* 三、浏览器向服务器发送http请求
* 四、服务器处理请求，浏览器接收HTTP响应
```
常见状态码：
200： 请求成功
302： 临时重定向
404： 没有找到资源
500： 服务端错误
```
* 五、浏览器解析渲染页面
* 六、连接结束，关闭TCP连接（四次挥手）

------

### 浏览器渲染原理
###### 1、HTML 文件并转换为 DOM 树
* 字节数据转为字符串
```
网络中传输的内容其实都是 0 和 1 这些字节数据，将这些字节数据转换为字符串，也就是我们写的代码。
```
* 字符串转为标记（这一过程叫标记化）
```
标记还是字符串，是构成代码的最小单位。
这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。
看下图就是一个标记：
```
<image src="/imgs/html_token" width=350></image>
* 标记转换为 Node
* Node 会根据不同 Node 之前的联系构建为一颗 DOM 树
<image src="/imgs/html-node" width=400></image>
###### 2、CSS 文件转换为 CSSOM 树
* 字节数据转为字符串
* 字符串转为标记
* 标记转换为 Node
* Node 之前的联系构建为一颗 CSSOM 树

###### 3、生成渲染树
* 将生成的 DOM 树和 CSSOM 树，组合为渲染树。
```bash
渲染树只会包括需要显示的节点和这些节点的样式信息，
如果某个节点是 display: none 的，那么就不会在渲染树中显示。
```
* 根据渲染树来进行布局（也可以叫做回流）
```bash
触发回流：
1、添加或者删除可见的DOM元素
2、元素尺寸改变--边距、填充、边框、宽度和高度
3、内容变化，比如用户在input中输入文字
4、浏览器窗口尺寸改变
5、计算offsetWidth和offsetHeight
```
* 调用 GPU 绘制，合成图层，显示在屏幕上（css3硬件加速）
```bash
会自动规避回流和重绘，下边的属性可以自动触发
transform
opacity
filter
will-change
```

###### 延伸题： 插入几万个 DOM，如何实现页面不卡顿？
* requestAnimationFrame 的方式去循环的插入 DOM
* 只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容  
###### 延伸题： 如果把 script 写在 head 里会阻塞页面渲染吗？ 写在 body 前呢？
```bash
不管 script 放到哪里，都会阻塞页面都渲染。
因为 js 很可能会影响 dom 结构，不阻塞的话，容易导致问题，性能浪费等等问题
```
###### 延伸题： 在 head 中的 script、css 加载是同时发生的吗？  
```bash
是同时的，但是要考虑浏览器的最大并发下载数目的限制
```
###### 延伸题： css 加载会阻塞页面渲染吗？
```bash
css 加载不会阻塞dom树的解析
css 加载会阻塞dom树的渲染
css 加载会阻塞后边 js 语句的执行
```
--------------
### 网络安全： XSS 、 CSRF攻击、 点击劫持、 中间人攻击
##### XSS
攻击者将可执行的代码注入到网页中。  
一般分为两种：  
* 持久型： 攻击的代码被服务端写入进数据库中，例如评价内容等  
* 非持久型： 一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。例如页面需要从url中获取数据直接展示到了页面上
###### 防御方法
* 转义字符： 对于用户的输入应该是永远不信任的。转义输入输出的内容，对于引号、尖括号、斜杠进行转义  
* 转义字符 + 白名单： 解决富文本直接转义导致无法正常使用的问题  
* CSP： 本质就是建立白名单。开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。  
**除非攻击者还控制了一台列入了白名单的可信主机**
```bash
# 开启方式
方法一： 设置 HTTP response Header 中的 Content-Security-Policy 字段
方法二： 设置 html 的 meta 标签， <meta http-equiv="Content-Security-Policy" content="">
# 规则内容在 1 中设置的值在 2 中是写到 content 属性中，
# 启用后，不符合csp的外部资源就会被阻止加载，chrome 会报错误信息。
```
具体限制值可查看 http://www.ruanyifeng.com/blog/2016/09/csp.html
##### CSRF
跨站请求伪造: 攻击者构造出一个请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑
###### 防御方法
* Get 请求不对数据进行修改
* 不让第三方网站访问到用户 Cookie
* 阻止第三方网站请求接口， 验证 Referer
* 请求时附带验证信息，比如验证码
* 请求时附带 Token： 服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。
##### 点击劫持
是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
<image src="/imgs/click_safe" width=400></image>

###### 防御方法
* 设置 HTTP 响应头 X-FRAME-OPTIONS
```js
配置取值
DENY: 表示页面不允许通过 iframe 的方式展示
SAMEORIGIN: 表示页面可以在相同域名下通过 iframe 的方式展示
ALLOW-FROM: 表示页面可以在指定来源的 iframe 中展示

// 不支持的浏览器中
<head>
  <style id="click-jack">
    html {
      display: none !important;
    }
  </style>
</head>
<body>
  <script>
  // 一个页面可能会有很多层，top 是指最顶层的框架
  // self 是指当前窗口
    if (self == top) {
      var style = document.getElementById('click-jack')
      document.body.removeChild(style)
    } else {
      top.location = self.location
    }
  </script>
</body>
```
##### 中间人攻击
攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。  
一般使用公共WiFi等时会发生
###### 防御方法
增加一个安全通道来传输信息。例如 HTTPS

---------

### HTTP
##### 基本优化
* 带宽：拨号上网的阶段带宽影响较大，但现在网络基础建设使带宽提升很多，不是主要问题了
* 延迟：
  * 浏览器阻塞： 浏览器对于同一个域名，同时只能有 4 个连接。超过最大连接数限制，后续请求就会被阻塞
  * DNS 查询： 浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的
  * 建立连接： HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接。每次请求都要经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
#### HTTP1.0 和 HTTP1.1 的一些区别
###### 缓存处理
```
HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，
HTTP1.1则引入了更多的缓存控制策略。
例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
```
###### 带宽优化及网络连接的使用
```
HTTP1.0中，存在一些浪费带宽的现象，
  例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
HTTP1.1则在请求头引入了range头域，
  它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
```
###### 错误通知的管理
```
在HTTP1.1中新增了24个错误状态响应码。
如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
 410（Gone）表示服务器上的某个资源被永久性的删除。
```
###### Host头处理
```
HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，
  因此，请求消息中的URL并没有传递主机名（hostname）。
HTTP1.1中在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。
HTTP1.1的请求消息和响应消息都应支持Host头域，
  且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
```
###### 长连接
```
HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，
在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，
在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
```
#### HTTPS与HTTP的一些区别
* HTTPS协议需要到CA申请证书
* HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
* HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
* HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

------------
