### 深复制
https://blog.csdn.net/weixin_33738982/article/details/91414115
### 手写bind方法
```js
function bind(){
  // Is this an error? We are invoking <call.bind> method before it's defined.
  var slice = Array.prototype.slice.call.bind(Array.prototype.slice);
  Function.prototype.bind = function() {
    var thatFunc = this, thatArg = arguments[0];
    var args = slice(arguments, 1);
    if (typeof thatFunc !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - ' +
        'what is trying to be bound is not callable');
    }
    return function(){
      var funcArgs = args.concat(slice(arguments))
      return thatFunc.apply(thatArg, funcArgs);
    };
  };
}
```
### 手写promise
```js

```
### 函数柯理化 实现 add(1,2) 和 add(1)(2) 都返回 3
```js
function curryingAdd(x) {
    return function (y) {
        return x + y
    }
}
curryingAdd(1, 2)           // 3
curryingAdd(1)(2)   // 3
```
### 防抖
```js
/**
 * 防抖
 * @param {function} func 回调函数
 * @param {number} wait 时间间隔
 * @param {boolean} immediate 调用是否前置
 * @return {function} 返回调用的函数
 */
export function debounce (func, wait = 50, immediate = true) {
  let timer, context, args;
  const later = () => {
    setTimeout(() => {
      timer = null;
      if (!immediate) {
        func.apply(context, args);
        context = args = null;
      }
    }, wait);
  }
  return function (...params) {
    if (!timer) {
      timer = later();
      if (immediate) {
        func.apply(this, params);
      } else {
        context = this;
        args = params;
      }
    } else {
      clearTimeout(timer);
      timer = later();
    }
  }
}
```
### 节流
```js
/**
 * 函数节流
 * @param {function} func 回调函数
 * @param {number} wait 时间间隔
 * @return {function} 返回调用函数
 */
export function throttle (func, wait = 50) {
  let context, args, result;
  let timeout = null;
  let previous = 0;
  const later = () => {
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  }
  return function() {
    let now = +new Date();
    let remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) {
        context = args = null;
      }
    } else if (!timeout) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  }
}
```
### 多个异步并发请求
所有的URL地址在urls参数中，同时可以通过max参数 控制请求的并发度。当所有的请求结束后，需要执行callback回调
```js
function sendRequest(arr, max, callback) {
  let fetchArr = [],  // 存储并发max的promise数组
    i = 0;
  function toFetch() {
    if (i === arr.length) {   // 所有的都处理完了， 返回一个resolve
      return Promise.resolve();
    }
    // 取出第i个url， 放入fetch里面 , 每取一次i++
    let one = fetch(arr[i++]);
    //将当前的promise存入并发数组中 
    fetchArr.push(one);
    one.then(() => {
      // 当promise执行完毕后，从数组删除
      fetchArr.splice(fetchArr.indexOf(one), 1)
    });
    let p = Promise.resolve();
    // 当并行数量达到最大后， 用race比较 第一个完成的， 然后再调用一下函数自身。
    if (fetchArr.length >= max) {
      p = Promise.race(fetchArr);
    }
    return p.then(() => toFetch());
  }
  // arr循环完后， 现在fetchArr里面剩下最后max个promise对象， 
  // 使用all等待所有的都完成之后执行callback
  toFetch().then(() => Promise.all(fetchArr)).then(() => {
    callback();
  })
}
```
### 整数逆向
```js
function reverseNum(num){
    num = String(num);
    let res = '';
    for(let i = num.length-1; i >= 0; i--){
        res += num[i];
    }
    return Number(res);
}
```
### 判断是否是回文
思路：从前往后和从后往前是一样的
```js
function confirmReverse(str){
  var totlen = str.length;
  var len = Math.floor(totlen / 2);
  for(var i = 0; i < len; i++) {
    if(str.charAt(i) != str.charAt(totlen - 1 - i)){
        return false;
    }else if (i == len - 1){
        return true;
    }
  } 
}
```
### 两个有序数组合并
```js
function mergeArray(arr1,arr2){
  var ind1 = 0; //标记arr1的对比元素的初始索引值
  var ind2 = 0; //标记arr2的对比元素的初始索引值
  var arr = []; //作为输出的新数组
  while(ind1 < arr1.length && ind2 < arr2.length){
    //当arr1和arr2元素均未全部存入arr中，则从数组第一个元素开始进行比较，将较小的元素存入arr中
    if(arr1[ind1] <= arr2[ind2]){
      arr.push(arr1[ind1]); //若arr1元素小于arr2元素，则将arr1的元素存入arr中
      ind1++;//已将元素push到输出数组中，将数组arr1的index指向移动到下一个
    } else {
      arr.push(arr2[ind2]);
      ind2++;
    }
  }
  //当不满足上述while条件时,就直接将剩余数组元素拼接在输出数组arr后面
  return arr.concat((ind1 < arr1.length) ? arr1.slice(ind1) : arr2.slice(ind2));
}
```
### 找出数组的所有子数组的组合
```js
function arrCon (arr) {
  var res = [];
  var dfs = function(res, arr, temp, start) {
    if (start >= arr.length) return;
    for (var i = start; i < arr.length; i++) {
      temp.push(arr[i]);
      dfs(res, arr, temp, i + 1);
      res.push(temp.slice());
      temp.pop();
    }
  }
  dfs(res, arr, [], 0);
  return res;
}
arrCon([1,2,3]);
// [[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]
```
### 数组内找出和为M的子数组
```js
function comSum (arr, target) {
  var res = [];
  var dfs = function(res, arr, target, temp, start) {
    if (target < 0) return;
    if (target == 0) {
      res.push(temp.slice());
      return;
    }
    for (var i = start; i < arr.length; i++) {
      temp.push(arr[i]);
      dfs(res, arr, target - arr[i], temp, i + 1);
      console.log(temp);
      temp.pop();
    }
  }
  dfs(res, arr, target, [], 0);
  return res;
}
```
### 从一个无序数组中，选取N个数，使其和为M
思路：找出所有的组合，然后从所有组合中找出符合条件的组合
```js
// 找出所有的组合
function arrCon (arr) {
  var res = [];
  var dfs = function(res, arr, temp, start) {
    if (start >= arr.length) return;
    for (var i = start; i < arr.length; i++) {
      temp.push(arr[i]);
      dfs(res, arr, temp, i + 1);
      res.push(temp.slice());
      temp.pop();
    }
  }
  dfs(res, arr, [], 0);
  return res;
}
/**
* arr: 目标数组
* count: 选取元素个数
* sum: 目标和
*/
function search (arr, count, sum) {
    let result = [];
    let arrConArr = arrCon(arr);
    // 从所有组合中找出符合条件的项
    for (let i = 0, iLen = arrConArr.length; i < iLen; i++) {
        if (arrConArr[i].length != count) continue;
        let tempSum = 0;
        for (let j = 0, jLen = arrConArr[i].length; j < jLen; j++) {
            tempSum += arrConArr[i][j];
        }
        if (tempSum == sum) {
            result.push(arrConArr[i]);
        }
    }
    return result;
}
search([1,2,3,4,5], 2, 7);
// [[2, 5], [3, 4]]
```
### 根据字符串取对象内的值
例如给对象 {a: [1, [{b: 2}]]} ， 字符串 a[1][0].b ,输出 2
```js
function get(obj, path){
    var arr = path.split(".");// arr[0]
    var reg = /\[(.*)\]/g;  
    var reg2 = /\w+(?=\[)|(?<=\[)(.*?)(?=\])/g;
    var temp;
    let temp2 = obj;
    for(let index = 0, iLen = arr.length; index < iLen; index++) {
        let item = arr[index];
        if(reg.test(item)){
            while(temp = reg2.exec(item)){
                temp2 = temp2[temp[0]];
            }
        }else{
            temp2 = temp2[item];
        }
        if (index == arr.length -1){
            return temp2;
        }
    }
}
console.log(get({a: [1, [{b: 2}]]}, 'a[1][0].b'));
```
### 题目： /imgs/interview/异步任务.jpg  设计一个异步任务Task
```js
class Task {
    constructor() {
        this.fnArr = [];
        this.nowFn = null;
        this.stopStatus = false;
    }
    add(fn, context, ...args){
        if (!fn) {
            return false;
        }
        this.fnArr.push({
            fn: fn,
            context: context,
            args: args
        })
        return this;
    }
    run(){
        if (this.stopStatus) {
            return false;
        }
        this.nowFn = this.fnArr.shift() || null;
        if (this.nowFn) {
            this.nowFn.fn(this.fnArr[0] ? () => {
                this.run(); // 注意此处不要直接 this.run，要放到一个箭头函数内，来保存this指向
            } : function(){return false;}, this.nowFn.context, this.nowFn.args);
        } else {
            console.log('no task.');
        }
        return this;
    }
    stop() {
        this.stopStatus = true;
    }
}

function task1(next){
    setTimeout(()=>{
        console.log(11);
        next();
    },1000)
}

function task2(next, b){
    setTimeout(()=>{
        console.log('bbb: ', b);
        next();
    },1000)
}

let task = new Task();
task.add(task1).add(task2,'null',3);
task.run();
```
### 题目： /imgs/interview/实例+异步.jpg  
```js
class Person {
    constructor(name) {
        this.fnArr = [];
        this.fnArr.push({
            fn: 'nameRent',
            param: name
        })
        setTimeout(() => {
            this.init();
        },0)
        
    }
    async init() {
        // await 只能用在async方法内，此处不可以用foreach等方法，只能放在for循环内。
        for (let i = 0, iLen = this.fnArr.length; i < iLen; i++){
            await this[this.fnArr[i].fn](this.fnArr[i].param)
        }
    }
    sleep(time){
        this.fnArr.push({
            fn: 'sleepRent',
            param: time
        })
        return this;
    }
    eat(lanch){
        this.fnArr.push({
            fn: 'eatRent',
            param: lanch
        })
        return this;
    }
    sleepFirst(time) {
        this.fnArr.unshift({
            fn: 'sleepRent',
            param: time
        })
        return this;
    }
    nameRent(name) {
        // await 可以是非 promise 的方法
        console.log(`Hi, this is ${name}`);
    }
    sleepRent(time) {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log(`Wake up after ${time}`)
                resolve();
            }, time);
        })
    }
    eatRent(lanch) {
        console.log(`Eat ${lanch}`);
    }
}

new Person('li').eat('supper').sleepFirst(3000).eat('dinner').sleep(2000);
```
### abcDefGhi 转为 abc.def.ghi
```js
// 下划线转换驼峰
function toHump(name) {
  return name.replace(/\_(\w)/g, function(all, letter){
    return letter.toUpperCase();
  });
}
// 驼峰转换下划线
function toLine(name) {
  return name.replace(/([A-Z])/g,"_$1").toLowerCase();
}

let a = 'a_b2_345';
toHump(a); // aB2345
let b = 'aBdaNf';
toLine(b); // a_bda_nf
```
### 数组sort(compare)
对数组与参数n的距离排序。
例如数组 [7,4,28,-1,0,7,33]， 按与 数值 4的距离大小排序
```js
function sort(arr, n){
  function compare(n){
    return function(val1, val2){
      return Math.abs(val1-n) - Math.abs(val2-n);
    }
  }
  return arr.sort(compare(n))
}
let arr = [7,4,28,-1,0,7,33];
sort(arr, 4);
// [4, 7, 7, 0, -1, 28, 33]
```
### 实现两个超过最大正整数的加和运算
```js
function pad(target, n) {
  return Array((n + 1) - target.split('').length).join('0') + target;
}
function add (a, b) {
    let maxLen = Math.max(a.length, b.length);
    let sumArr = [];
    let addOne = 0;
    a = pad(a, maxLen);
    b = pad(b, maxLen);
    for (let i = maxLen - 1; i >= 0; i--) {
        let tempSum = Number(a.charAt(i)) + Number(b.charAt(i)) + addOne;
        if (tempSum > 9) {
            addOne = 1;
            tempSum = tempSum - 10;
        } else {
            addOne = 0;
        }
        sumArr.unshift(tempSum);
    }
    return addOne == 1 ? addOne + sumArr.join('') : sumArr.join('');
}
add('8293', '2222');
// '10515'
```
### 排序

