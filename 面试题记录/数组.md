### 数组方法汇总
https://juejin.im/post/5902d56e1b69e60058c634d6
### 判断是个数组
```js
Array.isArray(a)
a.constructor === Array
a instanceof Array  // a 的原型 是否在构造函数 Array 的原型链上
Array.prototype.isPrototypeOf(a)  // Array 是否在 a 的原型上
a.__proto__ === Array.prototype
Object.prototype.toString.apply(a) === '[object Array]';  // 应用的是Object.toString
```
### 数组平坦化
```js
function flatten (target) {
  var result = [];
  target.forEach(function(item) {
    if(Array.isArray(item)) {
      result = result.concat(flatten(item));
    } else {
      result.push(item);
    }
  });
  return result;
}
```
### 数组去重
```js
// ps: 数组中 NaN 的去重，indexOf 检测不到，可以用 includes ，或者 new Set() 
// 方法一: for...of + Object
// ps：此方法优点是快，缺点是不能识别 字符串 1 和数字 1， 会认为是 同一个，
function unique(arr) {
  let obj = {}
  for (let i of arr) {
    obj[i] = (obj[i] || 0) + 1
  }
  return Object.keys(obj)
}
// 方法二: 排序后遍历
function unique(arr) {
    arr = arr.sort()
    let result = [arr[0]]
    for (let i = 1, len = arr.length; i < len; i++) {
      let resLen = result.length
      arr[i] !== result[resLen - 1] && result.push(arr[i])
    }
    return result
}
// 方法三: filter + indexOf
function unique(arr) {
  return arr.filter((item, index, arr)=> {
    return arr.indexOf(item) === index
  })
}
// 方法四: new Set()
function unique(arr) {
  let set = new Set(arr);
  return [...set];   // 或者下边方式
  return Array.from(set);
}
```
### 数组交集 建议使用 es6 的 Set
### 数组并集 建议使用 es6 的 Set
### 数组差集 建议使用 es6 的 Set
