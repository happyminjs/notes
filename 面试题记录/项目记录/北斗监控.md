#### 错误上报收集
##### 网络抢占资源问题怎么解决？？？
##### 白屏判断时机
```
目前是延时5s。
没有用domLoad事件是因为异步情况，用此方法就不准确了。
```
##### promise 的 reject 了，但是没有处理
##### 原因
之前项目都是只有统计埋点和业务方接口失败的主动上报，对于前端的js执行错误没有进行监控，所以想着做了这个项目。
##### 借鉴来源
* js-tracker: 淘宝前端监控平台
* fundebug: 
##### 上报方式
采用的接口 get 方式。原因是：   
* get 一个请求包，post要两个      
* 应用 img src 的方式 ，不用考虑接口跨域问题    
```js
var errId = 'jsError'+new Date();
var img = new Image();
img.onload = img.onerror = function(){
  errId = null;
}
img.src = src
```
##### 收集的数据分三大类
* 性能数据
```js
window.performance 方法 timing 属性
白屏数据是根据 document.ElementFromPoint(x,y) API来判断是否白屏：
x,y： 可视区窗口的像素
返回 x,y 坐标的元素
将屏幕划分几块，然后根据判断返回的元素与配置的元素是否相同，达到80%的相同率则认为正常
```
* 设备数据，方便后边报错问题定位复现 
```
navigator.userAgent
用户设备
浏览器内核版本
请求参数
```
* 错误数据
##### 错误的类型
```
1、js 执行错误  
  兼容到ie6，根据filename对广告插件错误进行了缓存后隔一段时间再上报，业务js错误是实时上报的
2、Vue 组件一些错误   同vue，兼容到ie9
3、资源加载错误  兼容到ie6
4、http 请求错误  兼容到ie9
5、使用方的 try catch 到的错误
```
* js 执行错误: error + crossorigin(解决不同域名下js捕获的错误只有 script error，没有具体错误)  
```
1、因为有广告啥的经常会有很多错误导致频繁上报，性能不好，   
可以根据 filename 判断域名，只上报自己业务代码错误。
2、需要上线规范，如果错误很多，那么应该是测试不会通过的状态，
所以没有做定时异步上报。只是放到了异步上报，减少对页面业务运行的影响。
3、还未发送，浏览器就关闭了，错误数据就会丢失。
所以变量存储下来，
```
addEventListener webkit 内核   
attachEvent IE 浏览器  可以兼容到ie6    
```js
window.addEventListener('error', function(err){
  // js 取到的 err 实例，可以拿到哪些属性， 以使用 undefined 的变量为例
  err.message;  // Uncaught ReferenceError: a is not defined
  err.filename; // 报错文件
  err.lineno; // 报错行
  err.colno; // 报错列
  // 异常上报 。。。。
})
window.onerror = (message, source, lineno, colno, err) => {
  // 异常上报
}
```
* Vue / React 捕获异常
.vue / React 组件文件内错误，error 事件捕获不到，是因为 Vue 中有自己 try catch 捕获错误，这样就不会传到 error 事件触发了。
```js
// 需要用户页面初始化调用一下方法，
// 使用用户传入的 Vue，避免Vue 版本等乱七八糟的东西
function VueErrorHandler(_Vue){
  Vue.config.errorHandler = function (err, vm, info) {
    // handle error  
    // error 是错误内容，info vue 特定的错误信息，比如错误所在的生命周期钩子
    logErrorToMyService(error, info);
  }
}

// React
class ErrorBoundary extends React.Component{
  constructor(props){
    super(props)
  }
  componentDidCatch(error, info) {
    // error 错误处理
    logErrorToMyService(error, info);
  }
}
```
* 资源加载错误   
```
addEventListener 默认是捕获阶段触发的，此阶段是不会触发资源404的错误的
所以要捕获404错误，需要在添加事件的时候，设置第三个参数为true，即冒泡阶段触发
404错误的是没有 message 这些字段的，可根据这点来认为是资源加载错误
```
```js
window.addEventListener('error', function(err){
  if (!err.message){
    if (err.target && err.target.src){
      err.target.src; // 404文件的地址
      err.target.tagName; // 404 文件的类型； "SCRIPT"、"IMG"
      err.target.outerHTML; // 引入文件的标签
    }
  }
}, true)
```
* http 请求错误截取    
```js
// AOP 方式重写方法
let axiosUse = axios.Axios.prototype.use;
axios.Axios.prototype.use = function(fulfilled, rejected){
  let oldFulfilled = fulfilled;
  let oldRejected = rejected;
  fulfilled = function(...args) {
    // 接口成功处理
    oldFulfilled.call(this, ...args);
  }
  rejected = function(...args) {
    // 处理用户接口失败的上报
    oldRejected.call(this, ...args);
  }
  return axiosUse.call(this, fulfilled, rejected)
}
```
* 使用方 try catch 捕获到的错误
```
```

##### **性能数据**: 原理是应用 window.performance
* **目前还未解决问题**，首屏异步渲染时间问题
```
因为之前都是PHP模板渲染的，所以性能数据部分直接 performance api 就可以了，
但是后来很多首屏异步渲染的，此方法会不能计算到接口请求后再渲染的时间。
目前想法是提供一个方法，让业务使用方去调用上报时间
至于主动捕获实现，目前还没有想法
```
* performance.timing  页面整体的时间参数
其中对我们作用比较大的有下边的几个，可以计算出网页各阶段的耗时    

https://segmentfault.com/a/1190000008933191
```
白屏时间 ： loadEventEnd - domainLookupStart
domready时间 ： domContentLoadedEventEnd - navigationStart
onload时间 ： loadEventEnd - navigationStart
DNS查询耗时 ： domainLookupEnd - domainLookupStart
TCP链接耗时 ： connectEnd - connectStart
request请求耗时 ： responseEnd - responseStart
解析dom树耗时 ： domComplete - domInteractive
```
下面是具体参数详解：
```
** navigationStart ** ：从同一个浏览器上下文的上一个文档卸载(unload)结束时的时间戳
responseStart ：浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳
responseEnd ：用户代理接收到最后一个字符的时间戳
domainLookupStart ：域名查询开始的时间戳
domainLookupEnd ：域名查询结束的时间戳
connectStart ：返回HTTP请求开始向服务器发送时的毫秒时间戳
connectEnd ：返回浏览器与服务器之间的连接建立时的毫秒时间戳
domInteractive ：当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳
domComplete：当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的时间戳
domContentLoadedEventEnd ：当前网页所有需要执行的脚本执行完成时的时间戳
loadEventEnd ：当前网页load事件的回调函数运行结束时的时间戳，如果该事件还没有发生，返回0。
unloadEventStart ：unload事件抛出时的时间戳。
unloadEventEnd ：unload事件处理完成时的时间戳
redirectStart ：第一个HTTP重定向开始时的时间戳，若没有则返回0
redirectEnd ：最后一个HTTP重定向完成时的时间戳，若没有则返回0
fetchStart ：浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳
secureConnectionStart ：浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。
requestStart ：浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。
domLoading ：当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的时间戳
domContentLoadedEventStart ：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的时间戳。
loadEventStart ：当前网页load事件的回调函数开始时的时间戳。如果该事件还没有发生，返回0。
```
* performance.getEntries()
```
返回页面所有静态资源的从开始发出请求到获取响应之间各个阶段的时间
包括 Js, CSS，图片，音频视频等等
```
<image src="/imgs/performance_1.png" width=900></image>
* performance.getEntriesByName(name)   
```
根据 name 值查询，例如上边的name值，返回上边相应name值的项组成的数组
```
<image src="/imgs/performance_2.png" width=700></image>
* performance.getEntriesByType(entryType)   
```
根据 entryType 值查询，例如上边的 entryType 值，返回上边相应 entryType 值的项组成的数组
```
* performance.mark(name)
```
添加 name 为 name 的，entryType 为 mark 的时间节点
```
<image src="/imgs/performance_3.png" width=400></image>
