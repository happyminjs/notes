### HTTP
##### 常用 header
* origin
* withCridies
* catch-control 1.1 强缓存
* expire 1.0 强缓存
* eTag 1.1 协商缓存
* last-modify 1.0 协商缓存
* keep-alive 长连接
* content-length
##### 常见状态码
| 状态码 | 描述 | 应用场景 |
| -- | -- | -- |
| 301 | 永久重定向 | 网站更换域名、删除网站中某些目录 |
| 302 | 临时重定向 | M端访问pc地址跳转到pc地址 |
| 304 | 未修改 | 使用协商缓存时，如果资源未修改，返回304 |
| 400 | 错误请求 | 客户端请求语法错误，服务器无法理解 |
| 403 | 服务器拒绝 | 客户端请求正确，但是服务器拒绝处理 |
| 408 | request 超时 | 服务器等待客户端发送的请求时间过长，超时 |
| 500 | 服务器错误 | 服务内部出错 |
| 502 | 网关错误 | 网关错误 |
#### 七层网络模型
```
1、物理层  网线或者WiFi
2、数据链路层 以太网所在层，进行物理寻址，  交换机
3、网络层  逻辑地址寻址，不同网络之间的路径选择。 IP地址选择和路由器 
4、传输层 建立、维护端到端的链接  TCP、UDP
5、会话层 建立、管理、终止会话
6、表示层 数据编码和转化，确保不同系统应用层发送的可互相识别
7、应用层 面向用户的， HTTP/FTP/SMTP
```
#### TCP
* TCP可靠： 无乱序、丢包重传，流控，拥塞控制
* 在7层模型中的第四层 - 传输层，
* 传递内容名称
```
seq: sequence number, 记录包的序号，解决网络中乱序问题
ack: acknowledgement number, 确认序列号，用来确认已收到的包，不丢包问题
tcp flag: 包类型，控制 tcp 状态机的
```
#### TCP 和 UDP 的区别
* TCP必须三次握手建立可靠连接后才可以传输数据，可靠，数据正确性
* UDP是非连接协议，不需要建立连接，可能丢包，不保证数据顺序
* TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因 此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。
* TCP 只能是 1 对 1 的，而UDP 支持 1 对 1,1 对多。
* TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。

##### 字段解释
> ACK、SYN 和 FIN 这些大写的单词表示标志位，其值要么是1，要么是0
> ack、seq小写的单词表示序号
> 大写的值为1的，小写的才有效


| 字段 | 解释 |
| -- | --  | 
| 序列号 seq | 报文顺序号 | 
| 确认号 ack | 一般值为收到报文的序列号加 1 | 
| 确认标识 ACK | 确认号 ack 是否有效，为 1 时 ack 才有效 | 
| 建立链接标识 SYN | 请求建立链接，并在其序列号的字段进行序列号的初始值设定。 | 
| 终止标识 FIN | 断开链接请求 | 
#### 三次握手
* 第一次握手： 客户端发送SYN报文，进入syn_send状态，等待服务器的确认    
* 第二次握手： 服务器收到syn报文，给客户端发送ack(确认)+syn(服务端的)报文，服务器进入 syn_rcvd 状态    
* 第三次握手： 客户端收到ack+syn报文，向服务端发送确认包，客户端进入 established 状态。服务器收到客户端发送的ack包后，也进入 established 状态    
* 然后开始传输数据   
##### 为什么不可以二次握手
* 需要确认双方的 收和发 能力     
```
第一次握手： 服务端确认客户端可以发，服务端可以收
第二次握手： 客户端知道服务端 发和收都没有问题，自己的接收和发送都正常
第三次握手： 服务端知道客户端的接收没有问题
所以三次才能双方确认双方的接收和发送能力正常
```
* 序列号可靠同步    
```
如果只有两次，则服务端不知道客户端是否已收到自己发的初始序列号，
如果第二次握手的报文丢失，那么客户端就不知道服务端的初始序列号，
这样TCP的可靠性就没有了
```
* 阻止重复历史连接的初始化   
```
如果客户端某种原因发送了两个不同序号的syn包，旧的包可能先达到服务器，
服务器收到后就会立即建立连接，就会造成网络异常 
```
##### 三次握手可以携带数据吗
```
前两次不可以，第三次可以  
```
#### 四次挥手    fin(final ?)
* 第一次挥手： 客户端发送 FIN 报文(fin=1)，进入 fin_wait_1 状态      
* 第二次挥手： 服务器收到 fin 报文，给客户端发送 ack(确认)+seq(服务端的)报文，服务器进入 close_wait 状态，   
```
此时客户端已没有数据要发送了，但是服务端有数据发送的话，客户端依然要接收   
客户端收到确认后，进入 fin_wait_2 状态
```
* 第三次挥手： 服务端数据发送完毕，发送 fin 包，服务器进入 last_ack 状态   
* 第四次挥手： 客户端收到服务器 fin 包后，发出确认包
```
然后客户端进入 time_wait 状态，但是要经过 2 个 MSL 后，才会close
服务器收到客户端的确认包后，直接关闭close

2 MSL 后再关闭，是因为可能这个确认包没有服务器没有收到，
此时是需要再次发送一个确认包的，所以要等待两个报文在网络中的最大生存时间。
```
##### 为什么建立要三次，关闭要四次
```
因为tcp是全双工通信，在主动关闭方发送 fin 包后，
接收端可能 还有数据要传输，不能立即关闭，
但是又得给出接收到结束的应答，所以只能先回复确认
等数据传输结束后，再发送 fin 包
```
##### 为什么 SYN/FIN 不包含数据却要消耗一个序列号
##### 
#### HTTPS与HTTP的一些区别
简单说就是：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全
* HTTPS协议需要到CA申请证书
* HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
* HTTP 无法加密是不安全的，而 HTTPS 对传输对数据进行加密是安全的
* HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
* HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的
* 在 OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
* HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
#### GET 和 POST 的区别
* get 参数放在url上，post 放在request body 中
* get 请求参数会完整的保留在浏览器历史记录中，post 不会
* get 产生一个TCP数据包，post一般产生两个(客户端对http的post和get的**请求策略决定**的)  
    * get 会将 http header 和 data 一起发出去，响应 200(返回数据)
    * post 先发送 header，服务器响应 100 continue，再发送 data，返回200(返回数据)
* get 浏览器会主动带 cache，而post不会，除非手动设置
* get 请求只能进行url编码，而post支持多种编码方式
* get 请求 url 的参数长度有限制，而post没有
* get 只接受 ASCII 字符的参数的数据类型，而post没有限制
* get 参数暴露在url上，不安全，不能用来传递敏感信息

#### WebSocket 和 HTTP
```
相同点
  都是一样基于TCP的，都是可靠性传输协议。
  都是应用层协议。 
不同点
  WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。
  HTTP是单向的。
  WebSocket是需要握手进行建立连接的
  相对HTTP来说，WebSocket是一种持久化的协议。它会基于HTTP协议，来完成一部分握手，HTTP握手部分完成，协议升级为WebSocket
```
----

##### 基本优化
* 带宽：拨号上网的阶段带宽影响较大，但现在网络基础建设使带宽提升很多，不是主要问题了
* 延迟：
  * 浏览器阻塞： 浏览器对于同一个域名，同时只能有 4 个连接。超过最大连接数限制，后续请求就会被阻塞
  * DNS 查询： 浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的
  * 建立连接： HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接。每次请求都要经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
#### HTTP1.0 和 HTTP1.1 的一些区别
###### 缓存处理
```
HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，
HTTP1.1则引入了更多的缓存控制策略。
例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
```
###### 带宽优化及网络连接的使用
```
HTTP1.0中，存在一些浪费带宽的现象，
  例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
HTTP1.1则在请求头引入了range头域，
  它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
```
###### 错误通知的管理
```
在HTTP1.1中新增了24个错误状态响应码。
如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
 410（Gone）表示服务器上的某个资源被永久性的删除。
```
###### Host头处理
```
HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，
  因此，请求消息中的URL并没有传递主机名（hostname）。
HTTP1.1中在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。
HTTP1.1的请求消息和响应消息都应支持Host头域，
  且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
```
###### 长连接
```
HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，
在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，
在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
```