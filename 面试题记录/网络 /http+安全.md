### 网络安全： XSS 、 CSRF攻击、 点击劫持、 中间人攻击
##### XSS
攻击者将可执行的代码注入到网页中。  
一般分为两种：  
* 持久型： 攻击的代码被服务端写入进数据库中，例如评价内容等  
* 非持久型： 一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。例如页面需要从url中获取数据直接展示到了页面上
###### 防御方法
* 转义字符： 对于用户的输入应该是永远不信任的。转义输入输出的内容，对于引号、尖括号、斜杠进行转义  
* 转义字符 + 白名单： 解决富文本直接转义导致无法正常使用的问题  
* CSP： 本质就是建立白名单。开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。  
**除非攻击者还控制了一台列入了白名单的可信主机**
```bash
# 开启方式
方法一： 设置 HTTP response Header 中的 Content-Security-Policy 字段
方法二： 设置 html 的 meta 标签， <meta http-equiv="Content-Security-Policy" content="">
# 规则内容在 1 中设置的值在 2 中是写到 content 属性中，
# 启用后，不符合csp的外部资源就会被阻止加载，chrome 会报错误信息。
```
具体限制值可查看 http://www.ruanyifeng.com/blog/2016/09/csp.html
##### CSRF
跨站请求伪造: 攻击者构造出一个请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑
###### 防御方法
* Get 请求不对数据进行修改
* 不让第三方网站访问到用户 Cookie
* 阻止第三方网站请求接口， 验证 Referer
* 请求时附带验证信息，比如验证码
* 请求时附带 Token： 服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。
##### 点击劫持
是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
<image src="/imgs/click_safe" width=400></image>

###### 防御方法
* 设置 HTTP 响应头 X-FRAME-OPTIONS
```js
配置取值
DENY: 表示页面不允许通过 iframe 的方式展示
SAMEORIGIN: 表示页面可以在相同域名下通过 iframe 的方式展示
ALLOW-FROM: 表示页面可以在指定来源的 iframe 中展示

// 不支持的浏览器中
<head>
  <style id="click-jack">
    html {
      display: none !important;
    }
  </style>
</head>
<body>
  <script>
  // 一个页面可能会有很多层，top 是指最顶层的框架
  // self 是指当前窗口
    if (self == top) {
      var style = document.getElementById('click-jack')
      document.body.removeChild(style)
    } else {
      top.location = self.location
    }
  </script>
</body>
```
##### 中间人攻击
攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。  
一般使用公共WiFi等时会发生
###### 防御方法
增加一个安全通道来传输信息。例如 HTTPS   

------------------

### GET 和 POST 的区别
* get 参数放在url上，post 放在request body 中
* get 产生一个TCP数据包，post产生两个  
    * get 会将 http header 和 data 一起发出去，响应 200(返回数据)
    * post 先发送 header，服务器响应 100 continue，再发送 data，返回200(返回数据)
* GET 在浏览器回退时是无害的，而 POST 会再次提交请求
* GET 产生的 URL 地址 可被 bookmark，而 post 不可以
* get 浏览器会主动带 cache，而post不会，除非手动设置
* get 请求只能进行url编码，而post支持多种编码方式
* get 请求参数会完整的保留在浏览器历史记录中，post 不会
* get 请求 url 的参数长度有限制，而post没有
* get 只接受 ASCII 字符的参数的数据类型，而post没有限制
* get 参数暴露在url上，不安全，不能用来传递敏感信息

### HTTP
##### 常用 header
* origin
* withCridies
* catch-control 1.1 强缓存
* expire 1.0 强缓存
* eTag 1.1 协商缓存
* last-modify 1.0 协商缓存
* keep-alive 长连接
* content-length
##### 常见状态码
| 状态码 | 描述 | 应用场景 |
| -- | -- | -- |
| 301 | 永久重定向 | 网站更换域名、删除网站中某些目录 |
| 302 | 临时重定向 | M端访问pc地址跳转到pc地址 |
| 304 | 未修改 | 使用协商缓存时，如果资源未修改，返回304 |
| 400 | 错误请求 | 客户端请求语法错误，服务器无法理解 |
| 403 | 服务器拒绝 | 客户端请求正确，但是服务器拒绝处理 |
| 408 | request 超时 | 服务器等待客户端发送的请求时间过长，超时 |
| 500 | 服务器错误 | 服务内部出错 |
| 502 | 网关错误 | 网关错误 |
#### TCP
* TCP可靠： 乱序、丢包重传，流控，拥塞控制
* 在7层模型中的第四层，
* 传递内容名称
```
seq: sequence number, 记录包的序号，解决网络中乱序问题
ack: acknowledgement number, 确认序列号，用来确认已收到的包，不丢包问题
tcp flag: 包类型，控制 tcp 状态机的
```
#### TCP 和 UDP 区别
* TCP必须三次握手建立可靠连接后才可以传输数据，可靠，数据正确性
* UDP是非连接协议，不需要建立连接，可能丢包，不保证数据顺序

#### 三次握手
* 第一次握手： 客户端发送SYN报文，进入syn_send状态，等待服务器的确认    
* 第二次握手： 服务器收到syn报文，给客户端发送ack(确认)+syn(服务端的)报文，服务器进入 syn_rcvd 状态    
* 第三次握手： 客户端收到ack+syn报文，向服务端发送确认包，客户端进入 established 状态。服务器收到客户端发送的ack包后，也进入 established 状态    
* 然后开始传输数据   
##### 为什么不可以二次握手
* 需要确认双方的 收和发 能力     
```
第一次握手： 服务端确认客户端可以发，服务端可以收
第二次握手： 客户端知道服务端 发和收都没有问题，自己的接收和发送都正常
第三次握手： 服务端知道客户端的接收没有问题
所以三次才能双方确认双方的接收和发送能力正常
```
* 序列号可靠同步    
```
如果只有两次，则服务端不知道客户端是否已收到自己发的初始序列号，
如果第二次握手的报文丢失，那么客户端就不知道服务端的初始序列号，
这样TCP的可靠性就没有了
```
* 阻止重复历史连接的初始化   
```
如果客户端某种原因发送了两个不同序号的syn包，旧的包可能先达到服务器，
服务器收到后就会立即建立连接，就会造成网络异常 
```
##### 三次握手可以携带数据吗
```
前两次不可以，第三次可以  
```
#### 四次握手    fin(final ?)
* 第一次挥手： 客户端发送 FIN 报文(fin=1)，进入 fin_wait_1 状态      
* 第二次挥手： 服务器收到 fin 报文，给客户端发送 ack(确认)+seq(服务端的)报文，服务器进入 close_wait 状态，   
```
此时客户端已没有数据要发送了，但是服务端有数据发送的话，客户端依然要接收   
客户端收到确认后，进入 fin_wait_2 状态
```
* 第三次挥手： 服务端数据发送完毕，发送 fin 包，服务器进入 last_ack 状态   
* 第四次挥手： 客户端收到服务器 fin 包后，发出确认包
```
然后客户端进入 time_wait 状态，但是要经过 2 个 MSL 后，才会close
服务器收到客户端的确认包后，直接关闭close

2 MSL 后再关闭，是因为可能这个确认包没有服务器没有收到，
此时是需要再次发送一个确认包的，所以要等待两个报文在网络中的最大生存时间。
```
##### 为什么建立要三次，关闭要四次
```
因为tcp是全双工通信，在主动关闭方发送 fin 包后，
接收端可能 还有数据要传输，不能立即关闭，
但是又得给出接收到结束的应答，所以只能先回复确认
等数据传输结束后，再发送 fin 包
```

----

##### 基本优化
* 带宽：拨号上网的阶段带宽影响较大，但现在网络基础建设使带宽提升很多，不是主要问题了
* 延迟：
  * 浏览器阻塞： 浏览器对于同一个域名，同时只能有 4 个连接。超过最大连接数限制，后续请求就会被阻塞
  * DNS 查询： 浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的
  * 建立连接： HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接。每次请求都要经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
#### HTTP1.0 和 HTTP1.1 的一些区别
###### 缓存处理
```
HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，
HTTP1.1则引入了更多的缓存控制策略。
例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
```
###### 带宽优化及网络连接的使用
```
HTTP1.0中，存在一些浪费带宽的现象，
  例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能
HTTP1.1则在请求头引入了range头域，
  它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
```
###### 错误通知的管理
```
在HTTP1.1中新增了24个错误状态响应码。
如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
 410（Gone）表示服务器上的某个资源被永久性的删除。
```
###### Host头处理
```
HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，
  因此，请求消息中的URL并没有传递主机名（hostname）。
HTTP1.1中在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。
HTTP1.1的请求消息和响应消息都应支持Host头域，
  且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
```
###### 长连接
```
HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，
在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，
在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
```
#### HTTPS与HTTP的一些区别
简单说就是：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全
* HTTPS协议需要到CA申请证书
* HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
* HTTP 无法加密是不安全的，而 HTTPS 对传输对数据进行加密是安全的
* HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
* HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的
* 在 OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
* HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
