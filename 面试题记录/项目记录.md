#### 为什么不用 vue-cli，而是要自己搭建 webpack 环境
```
1、vue-cli不能满足项目需要
2、webpack和插件版本升级啥的更自由一些
3、项目基本都需要引入一些公司内部的插件，都 vue-cli 也得需要更改调整，不如自己搭建的更灵活方便
```
#### 介绍项目：从框架、框架间交互方式、同步异步

#### 封装 vue-ui 组件
##### 暴露出的参数和方法
```js
1、toast:  msg： 内容； time： 展示时间； cb：消失时候的回调
2、swiper： data： 图片list； current：默认展示第几项； showCount:第几页/总页 
          click：点击事件； 
3、switch： check： 是否选中； 
4、selecter: 
```
##### swiper 组件实现
分为两个组件，   
* 父组件swiper: setInterval 定时修改 currentIndex，以及边界处理   
* 子组件swiper-item 中判断 currentIndex 与 自己的index 是否相等来展示隐藏，用 vue 动画 ，transition 组件，来控制移动，设置 .v-enter-active,.v-leave-active,.v-leave-to,.v-enter的样式位置等   
```html
<!-- 使用 -->
<swiper>
  <swiper-item>
    slot
  </swiper-item>
</swiper>

<!-- swiper.vue -->
<div class="swiper">
  <slot></slot>
</div>

<!-- swiper-item -->
<transition>
  <div class="swiper" v-if="isShow">
    <slot></slot>
  </div>
</transition>
```
swiper 暴露出参数：
```
# 参数
autoplay: 是否自动播放
delay：播放间隔时间
init-index：初始index
loop: 是否可以头尾循环
# 方法
change(index){}  // 切换时当时显示的index
```
transition 组件样式
```css
/* swiper-item */
.v-enter-active, v-leave-active {
  transition: all .5s linear;
}
.v-leave-to{
  transform: translateX(-100%);
}
.v-enter{
  transform: translateX(100%);
}
.v-enter-active{
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
}
```
##### 用 transform 而不用 left 的原因
1、transform 不会触发回流， left等布局或者几何属性的都会引发回流  
2、会自动启动 GPU 加速，优化前端性能

-------
#### 错误上报收集
### 网络抢占资源问题怎么解决？？？
##### 借鉴来源
* js-tracker: 淘宝前端监控平台
* fundebug: 
##### 上报方式
采用的接口 post 方式。原因是：   
* 有修改数据，post 更安全一些      
* 数据长度问题， post 没有限制    

另外可以采用 image src 的方式，但是需要保证 url 的长度问题。
```js
var url = 'xxx';
new Image().src = url;
```
##### 收集的数据分三大类
* 性能数据
```js
window.performance 方法 timing 属性
```
* 设备数据
```
navigator.userAgent
用户设备
浏览器内核版本
请求参数
```
* 错误数据
##### 错误的类型
```
1、js 执行错误
2、Vue 组件一些错误
3、资源加载错误
4、http 请求错误
5、使用方的 try catch 到的错误
```
* js 执行错误: error + crossorigin(解决不同域名下js捕获的错误只有 script error，没有具体错误)  
```js
window.addEventListener('error', function(err){
  // js 取到的 err 实例，可以拿到哪些属性， 以使用 undefined 的变量为例
  err.message;  // Uncaught ReferenceError: a is not defined
  err.filename; // 报错文件
  err.lineno; // 报错行
  err.colno; // 报错列
  // 异常上报 。。。。
})
window.onerror = (message, source, lineno, colno, err) => {
  // 异常上报
}
```
* Vue / React 捕获异常
.vue / React 组件文件内错误，error 事件捕获不到，是因为 Vue 中有自己 try catch 捕获错误，这样就不会传到 error 事件触发了。
```js
// 需要用户页面初始化调用一下方法，
// 使用用户传入的 Vue，避免Vue 版本等乱七八糟的东西
function VueErrorHandler(_Vue){
  Vue.config.errorHandler = function (err, vm, info) {
    // handle error  
    // error 是错误内容，info vue 特定的错误信息，比如错误所在的生命周期钩子
    logErrorToMyService(error, info);
  }
}

// React
class ErrorBoundary extends React.Component{
  constructor(props){
    super(props)
  }
  componentDidCatch(error, info) {
    // error 错误处理
    logErrorToMyService(error, info);
  }
}
```
* 资源加载错误   
```
addEventListener 默认是捕获阶段触发的，此阶段是不会触发资源404的错误的
所以要捕获404错误，需要在添加事件的时候，设置第三个参数为true，即冒泡阶段触发
404错误的是没有 message 这些字段的，可根据这点来认为是资源加载错误
```
```js
window.addEventListener('error', function(err){
  if (!err.message){
    if (err.target && err.target.src){
      err.target.src; // 404文件的地址
      err.target.tagName; // 404 文件的类型； "SCRIPT"、"IMG"
      err.target.outerHTML; // 引入文件的标签
    }
  }
}, true)
```
* http 请求错误截取    
```js
// AOP 方式重写方法
let axiosUse = axios.Axios.prototype.use;
axios.Axios.prototype.use = function(fulfilled, rejected){
  let oldFulfilled = fulfilled;
  let oldRejected = rejected;
  fulfilled = function(...args) {
    // 接口成功处理
    oldFulfilled.call(this, ...args);
  }
  rejected = function(...args) {
    // 处理用户接口失败的上报
    oldRejected.call(this, ...args);
  }
  return axiosUse.call(this, fulfilled, rejected)
}
```
* 使用方 try catch 捕获到的错误
```
```

##### **性能数据**: 原理是应用 window.performance
* **碰到一个问题**，就是如果首屏异步渲染的，此方法会不能计算到接口请求后再渲染的时间。
* performance.timing  页面整体的时间参数
其中对我们作用比较大的有下边的几个，可以计算出网页各阶段的耗时
```
白屏时间 ： responseEnd - navigationStart
domready时间 ： domContentLoadedEventEnd - navigationStart
onload时间 ： loadEventEnd - navigationStart
DNS查询耗时 ： domainLookupEnd - domainLookupStart
TCP链接耗时 ： connectEnd - connectStart
request请求耗时 ： responseEnd - responseStart
解析dom树耗时 ： domComplete - domInteractive
```
下面是具体参数详解：
```
** navigationStart ** ：从同一个浏览器上下文的上一个文档卸载(unload)结束时的时间戳
responseStart ：浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳
responseEnd ：用户代理接收到最后一个字符的时间戳
domainLookupStart ：域名查询开始的时间戳
domainLookupEnd ：域名查询结束的时间戳
connectStart ：返回HTTP请求开始向服务器发送时的毫秒时间戳
connectEnd ：返回浏览器与服务器之间的连接建立时的毫秒时间戳
domInteractive ：当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳
domComplete：当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的时间戳
domContentLoadedEventEnd ：当前网页所有需要执行的脚本执行完成时的时间戳
loadEventEnd ：当前网页load事件的回调函数运行结束时的时间戳，如果该事件还没有发生，返回0。
unloadEventStart ：unload事件抛出时的时间戳。
unloadEventEnd ：unload事件处理完成时的时间戳
redirectStart ：第一个HTTP重定向开始时的时间戳，若没有则返回0
redirectEnd ：最后一个HTTP重定向完成时的时间戳，若没有则返回0
fetchStart ：浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳
secureConnectionStart ：浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。
requestStart ：浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。
domLoading ：当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的时间戳
domContentLoadedEventStart ：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的时间戳。
loadEventStart ：当前网页load事件的回调函数开始时的时间戳。如果该事件还没有发生，返回0。
```
* performance.getEntries()
```
返回页面所有静态资源的从开始发出请求到获取响应之间各个阶段的时间
包括 Js, CSS，图片，音频视频等等
```
<image src="/imgs/performance_1.png" width=900></image>
* performance.getEntriesByName(name)   
```
根据 name 值查询，例如上边的name值，返回上边相应name值的项组成的数组
```
<image src="/imgs/performance_2.png" width=700></image>
* performance.getEntriesByType(entryType)   
```
根据 entryType 值查询，例如上边的 entryType 值，返回上边相应 entryType 值的项组成的数组
```
* performance.mark(name)
```
添加 name 为 name 的，entryType 为 mark 的时间节点
```
<image src="/imgs/performance_3.png" width=400></image>

-----------------------------------
### 




